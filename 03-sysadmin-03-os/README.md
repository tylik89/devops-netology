# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"


###1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`.

```shell
$ strace /bin/bash -c 'cd /tmp'
...
chdir("/tmp")                           = 0
...
```
---

###2. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
   
    Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.

```shell
        В выводе strace видно неуспешные попытки открыть следующие файлы :
            stat("/home/vagrant/.magic.mgc", 0x7fffb28fd3c0) = -1 ENOENT (No such file or directory)
            stat("/home/vagrant/.magic", 0x7fffb28fd3c0) = -1 ENOENT (No such file or directory)
            openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)
        Далее идет успешное открытие и считывание данных из /etc/magic 
            stat("/etc/magic", {st_mode=S_IFREG|0644, st_size=111, ...}) = 0
        Далее происходит загрузка из стандартной базы знаний для утилиты file:
            openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3</usr/lib/file/magic.mgc>
```
База данных `file` на основании которой она делает свои догадки находиться по пути '/usr/share/misc/magic.mgc'

###3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

При удалении исходного файла и отсутствии возможности пересоздать файл, можно обнулить поток перенаправив на него /dev/null

---

###4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

 Зомби-процессы не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов.Такой процесс 
 будет удален из списка процессов после вызова родительским процессом системного вызова wait() для
 корректной обработки/чтения его статуса. 

---

###5. В iovisor BCC есть утилита `opensnoop` :
    ```
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

```shell
root@vagrant:/home/vagrant# opensnoop-bpfcc
PID    COMM               FD ERR PATH
1050   vminfo              4   0 /var/run/utmp
573    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
573    dbus-daemon        18   0 /usr/share/dbus-1/system-services
573    dbus-daemon        -1   2 /lib/dbus-1/system-services
573    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/
1050   vminfo              4   0 /var/run/utmp
573    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
573    dbus-daemon        18   0 /usr/share/dbus-1/system-services
573    dbus-daemon        -1   2 /lib/dbus-1/system-services
573    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/
589    irqbalance          6   0 /proc/interrupts
589    irqbalance          6   0 /proc/stat
```
---

###6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

strace uname -a - используется системный вызов uname():
`uname({sysname="Linux", nodename="vagrant", ...}) = 0`
цитата в man  uname 2:
`Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype,  hostname,  osrelease, 
         version, domainname}`
---
###7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
   
    Есть ли смысл использовать в bash `&&`, если применить `set -e`?


; - простой разделитель команд и если его использовать для разделения, например, двух команд, то каждая из них
будет безусловно запущена по очереди - сначала первая слева, затем вторая.
            
&& - это логический оператор И - то есть вторая команда будет запущена только при условии, что первая завершилась
успешно - с нулевым кодом завершения.
      
set -e, указывает скрипту чтобы он завершился, если одна из команд вернула ненулевой ответ.

---

###8.Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

 `-e` останавливает выполнение команд, если получен код завершения отличный от нулевого в ходе исполнения любой из команд
 в конвеере. 

 `-u` останавливает выполнение и пишет в stderr сообщение об ошибке при попытке сослаться/использовать переменную
 окружения не определенную/заданную ранее в этом же скрипте. ОЧень полезно, чтобы избежать опечаток в имени переменных
 окружения, от которых может зависеть вся логика выполнения скрипта.
 
`-x` предписывает shell'у записывать в stderr каждую команду, которую подошла очередь выполнить. Полезно для отслеживания
 в каком именно виде запускаются команды на выполнение и на каком моесте возникает ошибка, например.
 
`-o pipefail` позволяет передать ненулевой код завершения любой из команд в конвеере в качестве конечного результата
 завершения всей команды, а не только последней команды. По сути, в сочетании с -e не так и важно, т.к. все равно в
 момент возникновения ошибки все последующие команды прерываются и работа завершается.


###10. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

 Наиболее часто встречаются статусы: S (вариации: S, Ss, Ss+, Ssl) - cпящий: ожидают системного события до своего завершения;

I (вариации: I, I<) - неактивный поток ядра (процесс бездействует);

Дополнительные символы:

`s`лидер сеанса,

`+` принадлежность группа процессов переднего плана,

`l `многопоточный (с использованием CLONE_THREAD),

`<` высокий приоритет.

 ---


